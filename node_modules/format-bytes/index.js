'use strict';

const units = 'bytes KB MB GB TB PB EB ZB YB'.split(' ');

function formatBytes(bytes) {
  assert(arguments.length === 1, 'Must receive exactly one argument');

  assert(
    Number.isInteger(bytes) && bytes >= 0,
    'First argument must be a positive integer'
  );

  // Special case - singular form
  if (bytes === 1) {
    return '1 byte';
  }

  // Special case - output precision should not exceed input precision
  if (bytes < 100) {
    return String(bytes) + ' ' + units[0];
  }

  // Round before choosing unit
  const round = Number(bytes.toPrecision(3));

  const magnitude = logFloor(round, 1000);

  // If we don't have a large enough unit, fall back to scientific notation.
  if (magnitude >= units.length) {
    return round.toPrecision(3).replace('e+', ' Ã— 10^') + ' ' + units[0];
  }

  return (
    (round / Math.pow(1000, magnitude)).toPrecision(3) + ' ' + units[magnitude]
  );
}

// Simpler implementations are often off by one due to floating point errors.
function logFloor(n, base) {
  const ceil = Math.round(Math.log(n) / Math.log(base));
  return ceil - (Math.pow(base, ceil) > n ? 1 : 0);
}

function assert(success, message) {
  if (!success) {
    throw Error(message);
  }
}

module.exports = formatBytes;